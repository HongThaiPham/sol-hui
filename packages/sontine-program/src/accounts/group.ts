/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getArrayDecoder,
  getArrayEncoder,
  getBooleanDecoder,
  getBooleanEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getI64Decoder,
  getI64Encoder,
  getOptionDecoder,
  getOptionEncoder,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  getU8Decoder,
  getU8Encoder,
  transformEncoder,
  type Account,
  type Address,
  type Codec,
  type Decoder,
  type EncodedAccount,
  type Encoder,
  type FetchAccountConfig,
  type FetchAccountsConfig,
  type MaybeAccount,
  type MaybeEncodedAccount,
  type Option,
  type OptionOrNullable,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  getAuctionConfigDecoder,
  getAuctionConfigEncoder,
  getCycleDurationDecoder,
  getCycleDurationEncoder,
  getGroupStatusDecoder,
  getGroupStatusEncoder,
  getSelectionMethodDecoder,
  getSelectionMethodEncoder,
  type AuctionConfig,
  type AuctionConfigArgs,
  type CycleDuration,
  type CycleDurationArgs,
  type GroupStatus,
  type GroupStatusArgs,
  type SelectionMethod,
  type SelectionMethodArgs,
} from '../types';

export const GROUP_DISCRIMINATOR = new Uint8Array([
  209, 249, 208, 63, 182, 89, 186, 254,
]);

export function getGroupDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(GROUP_DISCRIMINATOR);
}

export type Group = {
  discriminator: ReadonlyUint8Array;
  /** Group admin who can manage the group */
  admin: Address;
  /** Unique identifier for the group */
  groupId: bigint;
  /** Selection method for this group */
  selectionMethod: SelectionMethod;
  /** Current status of the group */
  status: GroupStatus;
  /** Maximum number of members allowed */
  maxMembers: number;
  /** Current number of members */
  currentMembers: number;
  /** Amount each member must contribute per round (in lamports) */
  contributionAmount: bigint;
  /** Duration of each round */
  cycleDuration: CycleDuration;
  /** Timestamp when the group was created */
  createdAt: bigint;
  /** Timestamp when the group started (first round) */
  startedAt: Option<bigint>;
  /** Current round number (0-indexed) */
  currentRound: number;
  /** Total number of rounds (equals max_members) */
  totalRounds: number;
  /** Vault account that holds the group's funds */
  vault: Address;
  /** Vault bump for PDA derivation */
  vaultBump: number;
  /** For fixed order selection: list of member pubkeys in order */
  fixedOrder: Array<Address>;
  /** Emergency pause flag */
  isPaused: boolean;
  /** Minimum members required to start (default: max_members) */
  minMembersToStart: number;
  /** Configuration for auction method */
  auctionConfig: Option<AuctionConfig>;
  /** Total amount collected so far */
  totalCollected: bigint;
  /** Total amount distributed so far */
  totalDistributed: bigint;
  /** Reserved space for future upgrades */
  reserved: ReadonlyUint8Array;
};

export type GroupArgs = {
  /** Group admin who can manage the group */
  admin: Address;
  /** Unique identifier for the group */
  groupId: number | bigint;
  /** Selection method for this group */
  selectionMethod: SelectionMethodArgs;
  /** Current status of the group */
  status: GroupStatusArgs;
  /** Maximum number of members allowed */
  maxMembers: number;
  /** Current number of members */
  currentMembers: number;
  /** Amount each member must contribute per round (in lamports) */
  contributionAmount: number | bigint;
  /** Duration of each round */
  cycleDuration: CycleDurationArgs;
  /** Timestamp when the group was created */
  createdAt: number | bigint;
  /** Timestamp when the group started (first round) */
  startedAt: OptionOrNullable<number | bigint>;
  /** Current round number (0-indexed) */
  currentRound: number;
  /** Total number of rounds (equals max_members) */
  totalRounds: number;
  /** Vault account that holds the group's funds */
  vault: Address;
  /** Vault bump for PDA derivation */
  vaultBump: number;
  /** For fixed order selection: list of member pubkeys in order */
  fixedOrder: Array<Address>;
  /** Emergency pause flag */
  isPaused: boolean;
  /** Minimum members required to start (default: max_members) */
  minMembersToStart: number;
  /** Configuration for auction method */
  auctionConfig: OptionOrNullable<AuctionConfigArgs>;
  /** Total amount collected so far */
  totalCollected: number | bigint;
  /** Total amount distributed so far */
  totalDistributed: number | bigint;
  /** Reserved space for future upgrades */
  reserved: ReadonlyUint8Array;
};

export function getGroupEncoder(): Encoder<GroupArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['admin', getAddressEncoder()],
      ['groupId', getU64Encoder()],
      ['selectionMethod', getSelectionMethodEncoder()],
      ['status', getGroupStatusEncoder()],
      ['maxMembers', getU8Encoder()],
      ['currentMembers', getU8Encoder()],
      ['contributionAmount', getU64Encoder()],
      ['cycleDuration', getCycleDurationEncoder()],
      ['createdAt', getI64Encoder()],
      ['startedAt', getOptionEncoder(getI64Encoder())],
      ['currentRound', getU8Encoder()],
      ['totalRounds', getU8Encoder()],
      ['vault', getAddressEncoder()],
      ['vaultBump', getU8Encoder()],
      ['fixedOrder', getArrayEncoder(getAddressEncoder())],
      ['isPaused', getBooleanEncoder()],
      ['minMembersToStart', getU8Encoder()],
      ['auctionConfig', getOptionEncoder(getAuctionConfigEncoder())],
      ['totalCollected', getU64Encoder()],
      ['totalDistributed', getU64Encoder()],
      ['reserved', fixEncoderSize(getBytesEncoder(), 64)],
    ]),
    (value) => ({ ...value, discriminator: GROUP_DISCRIMINATOR })
  );
}

export function getGroupDecoder(): Decoder<Group> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['admin', getAddressDecoder()],
    ['groupId', getU64Decoder()],
    ['selectionMethod', getSelectionMethodDecoder()],
    ['status', getGroupStatusDecoder()],
    ['maxMembers', getU8Decoder()],
    ['currentMembers', getU8Decoder()],
    ['contributionAmount', getU64Decoder()],
    ['cycleDuration', getCycleDurationDecoder()],
    ['createdAt', getI64Decoder()],
    ['startedAt', getOptionDecoder(getI64Decoder())],
    ['currentRound', getU8Decoder()],
    ['totalRounds', getU8Decoder()],
    ['vault', getAddressDecoder()],
    ['vaultBump', getU8Decoder()],
    ['fixedOrder', getArrayDecoder(getAddressDecoder())],
    ['isPaused', getBooleanDecoder()],
    ['minMembersToStart', getU8Decoder()],
    ['auctionConfig', getOptionDecoder(getAuctionConfigDecoder())],
    ['totalCollected', getU64Decoder()],
    ['totalDistributed', getU64Decoder()],
    ['reserved', fixDecoderSize(getBytesDecoder(), 64)],
  ]);
}

export function getGroupCodec(): Codec<GroupArgs, Group> {
  return combineCodec(getGroupEncoder(), getGroupDecoder());
}

export function decodeGroup<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>
): Account<Group, TAddress>;
export function decodeGroup<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>
): MaybeAccount<Group, TAddress>;
export function decodeGroup<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>
): Account<Group, TAddress> | MaybeAccount<Group, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getGroupDecoder()
  );
}

export async function fetchGroup<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<Account<Group, TAddress>> {
  const maybeAccount = await fetchMaybeGroup(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeGroup<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<MaybeAccount<Group, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeGroup(maybeAccount);
}

export async function fetchAllGroup(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<Account<Group>[]> {
  const maybeAccounts = await fetchAllMaybeGroup(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeGroup(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<MaybeAccount<Group>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeGroup(maybeAccount));
}
